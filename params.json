{
  "name": "pprint",
  "tagline": "A header-only library for C++(0x) that allows automagic pretty-printing of any container.",
  "body": "# pprint\r\n\r\n    Caution\r\n\r\n    This text is the little fixed version of the text wrote by\r\n    Louis Delacroix stored at https://github.com/louisdx/cxx-prettyprint as prettyprint.tex.\r\n\r\nWe present a header-only library for C++ which enables formatted output\r\nfor arbitrary containers in the usual style like\r\n`std::cout << x << std::endl;`. The only requirements on the type `T` of\r\n`x` is that it have a member type `T::const_iterator` and methods\r\n`T::begin()` and `T::end()`.\r\n\r\n## Introduction\r\n\r\nTemplated containers are fundamental in C++ and occur ubiquitously. Yet\r\nproducing formatted output of containers requires either a loop ranging\r\nover the container’s elements, or an overload of `operator<<` for the\r\ndesired container. One frequently finds oneself writing the same pattern\r\nof code time and time again. It would be handy if printing a container\r\nwould “just work”. This is what the `prettyprint` library achieves.\r\n\r\n## Expectations\r\n\r\nThis library was designed to meet the following generic expectations for\r\nformatted output of a container:\r\n\r\n-   The empty container should print as “`[]`”.\r\n-   A container with one element should print as “`[3]`”.\r\n-   A container with $n$ elements should print as “`[4, -1, 11, 8]`”.\r\n-   The container’s elements should be printed by recursively invoking formatted output.\r\n\r\nFormatted container output in this library has three parameters: The\r\nopening delimiter, the closing delimiter, and the separator. All three\r\nparameters should be customizable, but sensible defaults should be\r\nprovided so that formatted output works without any action on the user’s\r\npart. We chose to select the following defaults:\r\n\r\n-   The separator is always “`, `”.\r\n-   Pairs and tuples appear in round parentheses: “`(a, b)`”.\r\n-   Sets and (set-likes) appear in curly braces: “`{3, -7, 18}`”.\r\n-   All other containers appear in square brackets: “`[2, 2, 0, 1]`”.\r\n\r\nThese defaults are inspired by the prevailing typographic tradition of\r\nmathematical notation, and we hope that they are both intuitive and\r\næsthetically pleasing.\r\n\r\nNote that key-value containers are not treated specially, since their\r\nvalue type is simply `std::pair<key_type, mapped_type>`.\r\n\r\n## Acknowledgements\r\n\r\nCredits go to Marcelo Cantos for the initial approach, to Sven Groot for\r\nan improved, self-contained solution which became the foundation for\r\nthis code, and to StackOverflow’s Xeo for the tuple-printing code. This\r\nlibrary would not have been possible without the support of these\r\npeople.\r\n\r\n## Installation and Usage\r\n\r\nSimply make the header file `pprint/pprint.h` available and include it\r\nin your code. Containers can be printed immediately:\r\n\r\n```cpp\r\n#include <vector>\r\n#include <map>\r\n#include <set>\r\n#include <iostream>\r\n\r\n#include <pprint/pprint.h>\r\n\r\nint main()\r\n{\r\n  std::vector<int>        v;\r\n  std::set<double>        s;\r\n  std::map<size_t, void*> m;\r\n  int                     a[10];\r\n\r\n  // populate containers\r\n\r\n  std::cout << \"Vector:  \" << v << std::endl\r\n            << \"Set:     \" << s << std::endl\r\n            << \"Map:     \" << m << std::endl\r\n            << \"C-Array: \" << pretty_print::array_wrapper(a) << std::endl;\r\n}\r\n```\r\n\r\nThis will output something like the following:\r\n\r\n    Vector:  [1, 2, 3]\r\n    Set:     {4.2, -1.3, NaN}\r\n    Map:     [(15, CD01EF23), (9, 19283ABC), (25, D2A92158)]\r\n    C-Array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n\r\n## C-style arrays\r\n\r\nIn the usage example above we introduced a helper function called\r\n`pprint::array_wrapper` which can be used to print C-style arrays\r\nin the same fashion as other containers. It comes in two overloads, one\r\nfor compile-time sized arrays and one for dynamically sized arrays:\r\n\r\n    size_t n = get_number(), m = get_number();\r\n    int a[] = {1, 2, 4, 8};  // stack array of static size 4\r\n    int * b = new int[n];    // heap array of dynamic size n\r\n    int c[m];                // stack array of dynamic size m (VLA)\r\n\r\n    std::cout << pretty_print::array_wrapper(a)     << std::endl  // 1\r\n              << pretty_print::array_wrapper(b, n)  << std::endl  // 2\r\n              << pretty_print::array_wrapper(c, m); << std::endl  // 2\r\n\r\nIn case (1) the array size is deduced at compile time; in cases (2) and\r\n(3) the array size has to be passed explicitly to the wrapper function.\r\n\r\n## Advanced Features: Customizing Delimiters\r\n\r\n### Note\r\n\r\nAll internal of the library live in the namespace `pprint`.\r\n\r\nThe only advanced feature of the library at this point is the ability to\r\ncustomize the delimiters used during printing. There are two ways to do\r\nthis:\r\n\r\n-   Create a (partial or explicit) specialisation of a helper class for a specific container type and use the usual output syntax.\r\n-   Create a helper class holding custom delimiters and invoking a modified, slightly more verbose output function.\r\n\r\nThe two approaches meet orthogonal needs: If you have a container that\r\nis used repeatedly and which always must appear with custom delimiters,\r\nuse the first approach and specialize the `delimiters` struct for your\r\ncontainer type. On the other hand, if you have a set of delimiters that\r\nyou only want to use in certain situations (but with any sort of\r\ncontainer), create a helper class to hold your delimiters and invoke\r\noutput with the `custom_delims` function like this:\r\n\r\n```cpp\r\nstd::cout << pprint::custom_delims<MyDelims>(x) << std::endl;\r\n```\r\n\r\n### Method 1: Specialize\r\n\r\nThe default delimiter class is:\r\n\r\n```cpp\r\ntemplate <typename T, typename TChar> struct pprint::delimiters;\r\n```\r\n\r\nAll delimiter classes are templated on a character type `TChar`, which\r\nshould match the desired output stream parameter (i.e. `char` for\r\n`ostream` and `wchar_t` for `wostream`), and on the container type `T`.\r\nThe class has a static member constant `values` of type\r\n`delimiters_values<T, TChar>`, which itself is defined like this:\r\n\r\n```cpp\r\ntemplate<typename TChar> struct delimiters_values\r\n{\r\n    typedef TChar char_type;\r\n    const TChar * prefix;\r\n    const TChar * delimiter;\r\n    const TChar * postfix;\r\n};\r\n```\r\n\r\nBy providing an explicit or partial specialization of `delimiters`, the\r\ndelimiter parameters can be changed globally for a specific container\r\ntype.\r\n\r\n#### Example 1\r\n\r\nWe specialize for `std::vector<double>` to print “`((1.2; -3.4; 5.6))`”.\r\n\r\n```cpp\r\ntemplate <> const pprint::delimiters_values<char>\r\npprint::delimiters<std::vector<double>, char>::values = { \"((\", \"; \", \"))\" };\r\n```\r\n\r\n#### Example 2\r\n\r\nWe specialize for all `std::list<T>` to print “`a–b–c`”.\r\n\r\n```cpp\r\ntemplate <typename T> const pprint::delimiters_values<char>\r\npprint::delimiters<std::list<T>, char>::values = { \"\", \"--\", \"\" };\r\n```\r\n\r\n### Method 2: Custom delimiter class\r\n\r\nInstead of providing specializations for the default delimiter class, we\r\ncan also create our own delimiter class. It must provide a static member\r\nconstant `values` just like the default class. For example:\r\n\r\n```cpp\r\nstruct HalfOpen\r\n{\r\n  static const pprint::delimiters_values<wchar_t> values;\r\n};\r\nconst pprint::delimiters_values<wchar_t>\r\nHalfOpen::values = { L\"[\", L\", L\", \")\" };\r\n\r\nstd::wcout << pprint::custom_delims<HalfOpen>(x) << std::endl;\r\n```\r\n\r\n## Implementation\r\n\r\n[To be written.]\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}